#include <iostream>
#include <string>
#include <vector>
#include <atomic>
#include "base/config.h"
#include "base/factory.h"
#include "base/request.h"
#include "frontend/frontend.h"
#include "memory_system/memory_system.h"

using namespace Ramulator;

int main(int argc, char* argv[]) {
  if (argc < 2) {
    std::cerr << "Usage: " << argv[0] << " <config.yaml>" << std::endl;
    return 1;
  }

  // 1. Load Config (Official Way)
  YAML::Node config;
  try {
    config = Config::parse_config_file(std::string(argv[1]), {});
  } catch (const std::exception& e) {
    std::cerr << "ERROR: Config parsing failed: " << e.what() << std::endl;
    return 1;
  }

  // 2. Create System
  auto* frontend = Factory::create_frontend(config);
  auto* memsys = Factory::create_memory_system(config);

  if (!frontend || !memsys) {
    std::cerr << "ERROR: Could not create frontend or memory system." << std::endl;
    return 1;
  }

  frontend->connect_memory_system(memsys);
  memsys->connect_frontend(frontend);

  std::cout << "READY" << std::endl;

  // 3. Command Loop
  std::string cmd;
  while (std::cin >> cmd) {
    if (cmd == "EXIT") break;

    if (cmd == "TICK") {
      int cycles;
      std::cin >> cycles;
      for(int i=0; i<cycles; i++) {
        frontend->tick();
        memsys->tick();
      }
      std::cout << "OK" << std::endl;
    }
    else if (cmd == "REQ") {
      std::string addr_hex;
      int is_write;
      std::cin >> addr_hex >> is_write;
      
      uint64_t addr = std::stoull(addr_hex, nullptr, 16);
      
      // Send to Frontend (0=Read, 1=Write usually, check if flipped in your specific version)
      bool accepted = frontend->receive_external_requests(
          is_write ? 0 : 1, 
          addr, 
          0, 
          [](Request& r){}
      );

      std::cout << (accepted ? "ACCEPTED" : "STALLED") << std::endl;
    }
  }

  frontend->finalize();
  memsys->finalize();
  return 0;
}






# 1. Find the library you built earlier
LIB_PATH=$(find ramulator2 -name "libramulator*.so" | head -n 1)

if [ -z "$LIB_PATH" ]; then
    echo "‚ùå Error: Could not find libramulator.so. You must build Ramulator first."
    exit 1
fi

LIB_DIR=$(dirname "$LIB_PATH")
# Extract name 'ramulator' or 'ramulator2'
LIB_NAME=$(basename "$LIB_PATH" | sed 's/lib//' | sed 's/\.so//') 

echo "‚úÖ Found Library: $LIB_NAME in $LIB_DIR"

# 2. Compile the driver
g++ -o ramulator_driver \
    interactive_driver.cpp \
    -I ramulator2/src \
    -L "$LIB_DIR" \
    -l"$LIB_NAME" \
    -lyaml-cpp \
    -Wl,-rpath,"$LIB_DIR" \
    -O3

if [ -f "ramulator_driver" ]; then
    echo "üéâ SUCCESS! Executable created: ./ramulator_driver"
else
    echo "‚ùå Build failed."
fi







import subprocess
import os

class RamulatorEnv:
    def __init__(self, config_path):
        # Point to the NEW driver
        exe_path = "./ramulator_driver"
        
        if not os.path.exists(exe_path):
            raise FileNotFoundError(f"Driver not found at {exe_path}")

        # Launch
        self.proc = subprocess.Popen(
            [exe_path, config_path],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        # Wait for "READY"
        line = self.proc.stdout.readline().strip()
        if line != "READY":
            raise RuntimeError(f"Simulator failed to start: {line}")
        print("‚úÖ Ramulator Connected!")

    def step(self, action):
        # Action mapping: 0=Read, 1=Write, 2=Wait
        if action == 2:
            self.proc.stdin.write("TICK 1\n") 
            self.proc.stdin.flush()
            self.proc.stdout.readline() # Consume "OK"
            return 0, False

        else:
            # REQ <addr_hex> <is_write>
            addr_hex = "0x123400" 
            is_write = 1 if action == 1 else 0
            
            cmd = f"REQ {addr_hex} {is_write}\n"
            self.proc.stdin.write(cmd)
            self.proc.stdin.flush()
            
            response = self.proc.stdout.readline().strip()
            
            if response == "ACCEPTED":
                return 1, False
            elif response == "STALLED":
                return -0.1, False
            else:
                return 0, False

    def close(self):
        if self.proc:
            self.proc.stdin.write("EXIT\n")
            self.proc.terminate()




Frontend:
  impl: SimpleFrontend
  scheduler:
    impl: FRFCFS
  mem_size_limit_mb: 0 # 0 means use full capacity

MemorySystem:
  impl: DDR5
  clock: 2400 # 2400 MHz = DDR5-4800 MT/s
  organization:
    impl: DDR5
    density: 16Gb
    DQ: 8
    DGL: 4
  controller:
    impl: Generic
    Scheduler:
      impl: FRFCFS
    RefreshManager:
      impl: AllBank
    RowPolicy:
      impl: ClosedRowPolicy # Or 'OpenRowPolicy'
  timing:
    impl: DDR5
    rate: 2400
    tCK_ps: 416
    # Timing constraints (in cycles or ns)
    # These are standard JEDEC DDR5-4800 values
    tRCD: 40
    tRP: 40
    tRAS: 77
    tRC: 117
    tWR: 72
    tRTP: 18
    tCWL: 38
    tCCD_L: 12
    tCCD_S: 8
    tRRD_L: 12
    tRRD_S: 8
    tWTR_L: 24
    tWTR_S: 8
    tFAW: 40
    tRFC1: 410 # 16Gb density
    tRFC2: 220
    tRFCsb: 130
    tREFI: 9360 # 3.9us at >85C, or 7.8us at <85C (18720)
    # Voltage/Power (Optional, often separate plugin)
    VDD: 1.1

  # Address Mapping (Critical for performance)




g++ -std=c++20 -O2 interactive_main.cpp \
  -I ramulator2/src \
  -I ramulator2/ext/spdlog/include \
  -I ramulator2/ext/yaml-cpp/include \
  -L ramulator2 -lramulator \
  -Wl,-rpath,"$PWD/ramulator2" \
  -o ramulator2_interactive


g++ -std=c++20 -O2 interactive_main.cpp \
  -I ramulator2/src \
  -I ramulator2/build/_deps/spdlog-src/include \
  -I ramulator2/build/_deps/yaml-cpp-src/include \
  -L ramulator2 -lramulator \
  -Wl,-rpath,"$PWD/ramulator2" \
  -o ramulator2_interactive

  mapping:
    impl: RoBaRaCoCh # Row-Bank-Rank-Col-Channel
    # You can customize these bit positions based on your needs










# ddr5_config.yaml

Frontend:
  impl: ReadWriteTrace
  # Put any simple RW trace here (or keep the example_inst.trace style if you use that frontend)
  path: ./example_inst.trace
  clock_ratio: 3

Translation:
  impl: RandomTranslation
  # must be >= max address in your trace; this big value is commonly used
  max_addr: 1140736775975936

MemorySystem:
  impl: GenericDRAM
  clock_ratio: 3

  DRAM:
    impl: DDR5
    org:
      preset: DDR5_16Gb_x8
      channel: 1
      rank: 2
    timing:
      preset: DDR5_3200AN

  Controller:
    impl: Generic
    Scheduler:
      impl: FRFCFS
    RefreshManager:
      impl: AllBank
    RowPolicy:
      impl: ClosedRowPolicy
      cap: 4
    plugins: []

























Frontend:
  impl: SimpleFrontend
  scheduler:
    impl: FRFCFS
  mem_size_limit_mb: 0

MemorySystem:
  impl: DDR4
  clock: 2400
  organization:
    impl: DDR4
    density: 8Gb
    DQ: 8
    DGL: 4
  controller:
    impl: Generic
    Scheduler:
      impl: FRFCFS
    RefreshManager:
      impl: AllBank
    RowPolicy:
      impl: ClosedRowPolicy
  timing:
    impl: DDR4
    rate: 2400
    tCK_ps: 833
    tRCD: 14
    tRP: 14
    tRAS: 32
    tRC: 46
    tWR: 16
    tRTP: 8
    tCWL: 11
    tCCD_L: 6
    tCCD_S: 4
    tRRD_L: 6
    tRRD_S: 4
    tWTR_L: 8
    tWTR_S: 3
    tFAW: 24
    tRFC: 350
    tREFI: 7800
  mapping:
    impl: RoBaRaCoCh
  AddrMapper:
    impl: RoBaRaCoCh













# ============================
# DDR5 INTERACTIVE CONFIG
# (NO TRACE FILE REQUIRED)
# ============================

Frontend:
  impl: External
  clock_ratio: 1

Translation:
  impl: RandomTranslation
  max_addr: 1073741824   # 1 GiB address space (safe for testing)

MemorySystem:
  impl: GenericDRAM
  clock_ratio: 1

  DRAM:
    impl: DDR5
    org:
      preset: DDR5_16Gb_x8
      channel: 1
      rank: 1
    timing:
      preset: DDR5_3200AN

  Controller:
    impl: Generic
    Scheduler:
      impl: FRFCFS
    RowPolicy:
      impl: ClosedRowPolicy
      cap: 4
    RefreshManager:
      impl: AllBank
    plugins: []

  AddrMapper:
    impl: RoBaRaCoCh






















conda deactivate 2>/dev/null || true
unset CC CXX CFLAGS CXXFLAGS LDFLAGS CPPFLAGS

cd ramulator2
rm -rf build
mkdir build
cmake -S . -B build \
  -DCMAKE_BUILD_TYPE=Release \
  -DCMAKE_C_COMPILER=/usr/bin/gcc \
  -DCMAKE_CXX_COMPILER=/usr/bin/g++ \
  -DCMAKE_CXX_STANDARD=20 \
  -DCMAKE_POSITION_INDEPENDENT_CODE=ON
cmake --build build -j"$(nproc)"
cd ..


g++ -std=c++20 -O2 interactive_main.cpp \
  -I ramulator2/src \
  -I ramulator2/build/_deps/yaml-cpp-src/include \
  -I ramulator2/build/_deps/spdlog-src/include \
  -L ramulator2 -lramulator \
  -Wl,-rpath,"$PWD/ramulator2" \
  -o ramulator2_interactive


./ramulator2_interactive ramulator2/configs/ddr5_interactive.yaml


ldd ./ramulator2_interactive | grep -E "libstdc\+\+|libgcc|yaml|spdlog|ramulator"
ldd ./ramulator2/libramulator.so | grep -E "libstdc\+\+|libgcc|yaml|spdlog"








































SPD=$(find ramulator2 -type d -path "*spdlog*include*" | head -n 1)
YML=$(find ramulator2 -type d -path "*yaml*include*"   | head -n 1)

g++ -std=c++20 -O3 -o ramulator_driver \
  interactive_driver.cpp \
  -I ramulator2/src -I "$SPD" -I "$YML" \
  -L "$(pwd)/ramulator2" -lramulator \
  -Wl,-rpath,"$(pwd)/ramulator2"














from dram_rl.environment import RamulatorEnv
import os

config_path = "ddr5_config.yaml"

if not os.path.exists(config_path):
    print(f"‚ùå Error: {config_path} not found!")
    exit(1)

print(f"üöÄ Testing DDR5 Configuration: {config_path}")

try:
    # 1. Initialize
    env = RamulatorEnv(config_path)
    print("‚úÖ Environment Initialized")

    # 2. Test a WRITE (Action 1)
    print("   Sending WRITE Request...")
    reward, done = env.step(1)
    print(f"   -> Reward: {reward}")

    # 3. Test a READ (Action 0)
    print("   Sending READ Request...")
    reward, done = env.step(0)
    print(f"   -> Reward: {reward}")

    # 4. Test a WAIT/TICK (Action 2)
    print("   Sending TICK...")
    env.step(2)
    print("   -> Tick OK")

    env.close()
    print("üéâ DDR5 Test Passed!")

except Exception as e:
    print(f"‚ùå Test Failed: {e}")


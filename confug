#include <iostream>
#include <string>
#include <vector>
#include <atomic>
#include "base/config.h"
#include "base/factory.h"
#include "base/request.h"
#include "frontend/frontend.h"
#include "memory_system/memory_system.h"

using namespace Ramulator;

int main(int argc, char* argv[]) {
  if (argc < 2) {
    std::cerr << "Usage: " << argv[0] << " <config.yaml>" << std::endl;
    return 1;
  }

  // 1. Load Config (Official Way)
  YAML::Node config;
  try {
    config = Config::parse_config_file(std::string(argv[1]), {});
  } catch (const std::exception& e) {
    std::cerr << "ERROR: Config parsing failed: " << e.what() << std::endl;
    return 1;
  }

  // 2. Create System
  auto* frontend = Factory::create_frontend(config);
  auto* memsys = Factory::create_memory_system(config);

  if (!frontend || !memsys) {
    std::cerr << "ERROR: Could not create frontend or memory system." << std::endl;
    return 1;
  }

  frontend->connect_memory_system(memsys);
  memsys->connect_frontend(frontend);

  std::cout << "READY" << std::endl;

  // 3. Command Loop
  std::string cmd;
  while (std::cin >> cmd) {
    if (cmd == "EXIT") break;

    if (cmd == "TICK") {
      int cycles;
      std::cin >> cycles;
      for(int i=0; i<cycles; i++) {
        frontend->tick();
        memsys->tick();
      }
      std::cout << "OK" << std::endl;
    }
    else if (cmd == "REQ") {
      std::string addr_hex;
      int is_write;
      std::cin >> addr_hex >> is_write;
      
      uint64_t addr = std::stoull(addr_hex, nullptr, 16);
      
      // Send to Frontend (0=Read, 1=Write usually, check if flipped in your specific version)
      bool accepted = frontend->receive_external_requests(
          is_write ? 0 : 1, 
          addr, 
          0, 
          [](Request& r){}
      );

      std::cout << (accepted ? "ACCEPTED" : "STALLED") << std::endl;
    }
  }

  frontend->finalize();
  memsys->finalize();
  return 0;
}






# 1. Find the library you built earlier
LIB_PATH=$(find ramulator2 -name "libramulator*.so" | head -n 1)

if [ -z "$LIB_PATH" ]; then
    echo "‚ùå Error: Could not find libramulator.so. You must build Ramulator first."
    exit 1
fi

LIB_DIR=$(dirname "$LIB_PATH")
# Extract name 'ramulator' or 'ramulator2'
LIB_NAME=$(basename "$LIB_PATH" | sed 's/lib//' | sed 's/\.so//') 

echo "‚úÖ Found Library: $LIB_NAME in $LIB_DIR"

# 2. Compile the driver
g++ -o ramulator_driver \
    interactive_driver.cpp \
    -I ramulator2/src \
    -L "$LIB_DIR" \
    -l"$LIB_NAME" \
    -lyaml-cpp \
    -Wl,-rpath,"$LIB_DIR" \
    -O3

if [ -f "ramulator_driver" ]; then
    echo "üéâ SUCCESS! Executable created: ./ramulator_driver"
else
    echo "‚ùå Build failed."
fi







import subprocess
import os

class RamulatorEnv:
    def __init__(self, config_path):
        # Point to the NEW driver
        exe_path = "./ramulator_driver"
        
        if not os.path.exists(exe_path):
            raise FileNotFoundError(f"Driver not found at {exe_path}")

        # Launch
        self.proc = subprocess.Popen(
            [exe_path, config_path],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True,
            bufsize=1
        )

        # Wait for "READY"
        line = self.proc.stdout.readline().strip()
        if line != "READY":
            raise RuntimeError(f"Simulator failed to start: {line}")
        print("‚úÖ Ramulator Connected!")

    def step(self, action):
        # Action mapping: 0=Read, 1=Write, 2=Wait
        if action == 2:
            self.proc.stdin.write("TICK 1\n") 
            self.proc.stdin.flush()
            self.proc.stdout.readline() # Consume "OK"
            return 0, False

        else:
            # REQ <addr_hex> <is_write>
            addr_hex = "0x123400" 
            is_write = 1 if action == 1 else 0
            
            cmd = f"REQ {addr_hex} {is_write}\n"
            self.proc.stdin.write(cmd)
            self.proc.stdin.flush()
            
            response = self.proc.stdout.readline().strip()
            
            if response == "ACCEPTED":
                return 1, False
            elif response == "STALLED":
                return -0.1, False
            else:
                return 0, False

    def close(self):
        if self.proc:
            self.proc.stdin.write("EXIT\n")
            self.proc.terminate()




Frontend:
  impl: SimpleFrontend
  scheduler:
    impl: FRFCFS
  mem_size_limit_mb: 0 # 0 means use full capacity

MemorySystem:
  impl: DDR5
  clock: 2400 # 2400 MHz = DDR5-4800 MT/s
  organization:
    impl: DDR5
    density: 16Gb
    DQ: 8
    DGL: 4
  controller:
    impl: Generic
    Scheduler:
      impl: FRFCFS
    RefreshManager:
      impl: AllBank
    RowPolicy:
      impl: ClosedRowPolicy # Or 'OpenRowPolicy'
  timing:
    impl: DDR5
    rate: 2400
    tCK_ps: 416
    # Timing constraints (in cycles or ns)
    # These are standard JEDEC DDR5-4800 values
    tRCD: 40
    tRP: 40
    tRAS: 77
    tRC: 117
    tWR: 72
    tRTP: 18
    tCWL: 38
    tCCD_L: 12
    tCCD_S: 8
    tRRD_L: 12
    tRRD_S: 8
    tWTR_L: 24
    tWTR_S: 8
    tFAW: 40
    tRFC1: 410 # 16Gb density
    tRFC2: 220
    tRFCsb: 130
    tREFI: 9360 # 3.9us at >85C, or 7.8us at <85C (18720)
    # Voltage/Power (Optional, often separate plugin)
    VDD: 1.1

  # Address Mapping (Critical for performance)




g++ -std=c++20 -O2 interactive_main.cpp \
  -I ramulator2/src \
  -I ramulator2/ext/spdlog/include \
  -I ramulator2/ext/yaml-cpp/include \
  -L ramulator2 -lramulator \
  -Wl,-rpath,"$PWD/ramulator2" \
  -o ramulator2_interactive


g++ -std=c++20 -O2 interactive_main.cpp \
  -I ramulator2/src \
  -I ramulator2/build/_deps/spdlog-src/include \
  -I ramulator2/build/_deps/yaml-cpp-src/include \
  -L ramulator2 -lramulator \
  -Wl,-rpath,"$PWD/ramulator2" \
  -o ramulator2_interactive

  mapping:
    impl: RoBaRaCoCh # Row-Bank-Rank-Col-Channel
    # You can customize these bit positions based on your needs










# ddr5_config.yaml

Frontend:
  impl: ReadWriteTrace
  # Put any simple RW trace here (or keep the example_inst.trace style if you use that frontend)
  path: ./example_inst.trace
  clock_ratio: 3

Translation:
  impl: RandomTranslation
  # must be >= max address in your trace; this big value is commonly used
  max_addr: 1140736775975936

MemorySystem:
  impl: GenericDRAM
  clock_ratio: 3

  DRAM:
    impl: DDR5
    org:
      preset: DDR5_16Gb_x8
      channel: 1
      rank: 2
    timing:
      preset: DDR5_3200AN

  Controller:
    impl: Generic
    Scheduler:
      impl: FRFCFS
    RefreshManager:
      impl: AllBank
    RowPolicy:
      impl: ClosedRowPolicy
      cap: 4
    plugins: []

























Frontend:
  impl: SimpleFrontend
  scheduler:
    impl: FRFCFS
  mem_size_limit_mb: 0

MemorySystem:
  impl: DDR4
  clock: 2400
  organization:
    impl: DDR4
    density: 8Gb
    DQ: 8
    DGL: 4
  controller:
    impl: Generic
    Scheduler:
      impl: FRFCFS
    RefreshManager:
      impl: AllBank
    RowPolicy:
      impl: ClosedRowPolicy
  timing:
    impl: DDR4
    rate: 2400
    tCK_ps: 833
    tRCD: 14
    tRP: 14
    tRAS: 32
    tRC: 46
    tWR: 16
    tRTP: 8
    tCWL: 11
    tCCD_L: 6
    tCCD_S: 4
    tRRD_L: 6
    tRRD_S: 4
    tWTR_L: 8
    tWTR_S: 3
    tFAW: 24
    tRFC: 350
    tREFI: 7800
  mapping:
    impl: RoBaRaCoCh
  AddrMapper:
    impl: RoBaRaCoCh













# ============================
# DDR5 INTERACTIVE CONFIG
# (NO TRACE FILE REQUIRED)
# ============================

Frontend:
  impl: External
  clock_ratio: 1

Translation:
  impl: RandomTranslation
  max_addr: 1073741824   # 1 GiB address space (safe for testing)

MemorySystem:
  impl: GenericDRAM
  clock_ratio: 1

  DRAM:
    impl: DDR5
    org:
      preset: DDR5_16Gb_x8
      channel: 1
      rank: 1
    timing:
      preset: DDR5_3200AN

  Controller:
    impl: Generic
    Scheduler:
      impl: FRFCFS
    RowPolicy:
      impl: ClosedRowPolicy
      cap: 4
    RefreshManager:
      impl: AllBank
    plugins: []

  AddrMapper:
    impl: RoBaRaCoCh






















conda deactivate 2>/dev/null || true
unset CC CXX CFLAGS CXXFLAGS LDFLAGS CPPFLAGS

cd ramulator2
rm -rf build
mkdir build
cmake -S . -B build \
  -DCMAKE_BUILD_TYPE=Release \
  -DCMAKE_C_COMPILER=/usr/bin/gcc \
  -DCMAKE_CXX_COMPILER=/usr/bin/g++ \
  -DCMAKE_CXX_STANDARD=20 \
  -DCMAKE_POSITION_INDEPENDENT_CODE=ON
cmake --build build -j"$(nproc)"
cd ..


g++ -std=c++20 -O2 interactive_main.cpp \
  -I ramulator2/src \
  -I ramulator2/build/_deps/yaml-cpp-src/include \
  -I ramulator2/build/_deps/spdlog-src/include \
  -L ramulator2 -lramulator \
  -Wl,-rpath,"$PWD/ramulator2" \
  -o ramulator2_interactive


./ramulator2_interactive ramulator2/configs/ddr5_interactive.yaml


ldd ./ramulator2_interactive | grep -E "libstdc\+\+|libgcc|yaml|spdlog|ramulator"
ldd ./ramulator2/libramulator.so | grep -E "libstdc\+\+|libgcc|yaml|spdlog"








































SPD=$(find ramulator2 -type d -path "*spdlog*include*" | head -n 1)
YML=$(find ramulator2 -type d -path "*yaml*include*"   | head -n 1)

g++ -std=c++20 -O3 -o ramulator_driver \
  interactive_driver.cpp \
  -I ramulator2/src -I "$SPD" -I "$YML" \
  -L "$(pwd)/ramulator2" -lramulator \
  -Wl,-rpath,"$(pwd)/ramulator2"














from dram_rl.environment import RamulatorEnv
import os

config_path = "ddr5_config.yaml"

if not os.path.exists(config_path):
    print(f"‚ùå Error: {config_path} not found!")
    exit(1)

print(f"üöÄ Testing DDR5 Configuration: {config_path}")

try:
    # 1. Initialize
    env = RamulatorEnv(config_path)
    print("‚úÖ Environment Initialized")

    # 2. Test a WRITE (Action 1)
    print("   Sending WRITE Request...")
    reward, done = env.step(1)
    print(f"   -> Reward: {reward}")

    # 3. Test a READ (Action 0)
    print("   Sending READ Request...")
    reward, done = env.step(0)
    print(f"   -> Reward: {reward}")

    # 4. Test a WAIT/TICK (Action 2)
    print("   Sending TICK...")
    env.step(2)
    print("   -> Tick OK")

    env.close()
    print("üéâ DDR5 Test Passed!")

except Exception as e:
    print(f"‚ùå Test Failed: {e}")
















import gym
import numpy as np
import subprocess
import os
import sys
import time

class DramEnv(gym.Env):
    def __init__(self, config_file="ddr5_config.yaml"):
        super(DramEnv, self).__init__()
        
        # --- 1. SETUP PATHS ---
        # Path to the executable we built (Option A)
        self.exe_path = "./ramulator2/build/ramulator_interactive"
        
        # Verify Executable exists
        if not os.path.exists(self.exe_path):
            raise FileNotFoundError(f"‚ùå Executable not found at {self.exe_path}\nDid you run the 'Unified Build' script?")
        
        # Verify Config exists
        if not os.path.exists(config_file):
            raise FileNotFoundError(f"‚ùå Config file not found: {config_file}\nPlease create ddr5_config.yaml in the root folder.")

        print(f"[DramEnv] Launching Ramulator with {config_file}...")

        # --- 2. LAUNCH SIMULATOR (Subprocess Pipe) ---
        try:
            self.proc = subprocess.Popen(
                [self.exe_path, config_file],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                text=True,       # Text mode
                bufsize=1        # Line buffered
            )

            # Wait for "READY" signal from C++
            line = self.proc.stdout.readline().strip()
            if line != "READY":
                # Check for common error: "Unknown implementation"
                raise RuntimeError(f"Simulator failed to start. Output: '{line}'")
                
            print("‚úÖ Ramulator Connected via Pipe!")

        except Exception as e:
            print(f"‚ùå Crash during startup: {e}")
            sys.exit(1)

        # --- 3. RL SETUP ---
        # Action space: 0..99 (represents different attack patterns or addresses)
        self.action_space = gym.spaces.Discrete(100)
        # Observation space: 10 metrics (placeholder)
        self.observation_space = gym.spaces.Box(low=0, high=1, shape=(10,), dtype=np.float32)
        
        self.fault_history = set()

    def _send_req(self, addr, is_write):
        """Helper to send a single request via the Pipe"""
        if self.proc.poll() is not None:
            print("‚ùå Simulator process is dead.")
            return False

        # Command format: REQ <addr> <is_write>
        # 1 = Write, 0 = Read
        cmd = f"REQ {addr} {1 if is_write else 0}\n"
        
        try:
            self.proc.stdin.write(cmd)
            self.proc.stdin.flush()
            
            # Read response: ACCEPTED or STALLED
            response = self.proc.stdout.readline().strip()
            return response == "ACCEPTED"
        except (BrokenPipeError, IOError):
            return False

    def step(self, phase, action_id):
        """
        Executes an action in the simulator.
        
        phase 1: action_id is Pattern ID (Legacy Test)
        phase 2: action_id is Target Offset (Discovery/Attack)
        """
        base_addr = 0x100000 # 1MB Base
        fault_code = 0
        success = True
        
        # --- A. EXECUTE ACTION ---
        if phase == 1:
            # Phase 1: Simple Pattern Test
            # Write -> Read sequence
            self._send_req(base_addr, is_write=True)  
            success = self._send_req(base_addr, is_write=False) 
            
            # If the read was stalled/rejected, we count it as "congestion" (pseudo-fault)
            if not success: 
                fault_code = 1 

        else:
            # Phase 2: RowHammer / Topology Discovery
            # Target specific rows based on action_id
            # DDR5 Row size is large, so we jump by larger offsets
            offset = action_id * 0x2000 # 8KB jumps
            target = base_addr + offset
            
            # Aggressive Hammer: Write-Read-Write-Read rapid sequence
            self._send_req(target, True)
            self._send_req(target, False)
            self._send_req(target, True)
            success = self._send_req(target, False)

            # If we successfully hammered (accepted commands) but caused high latency/stall
            # we consider it a successful "hit"
            if not success:
                fault_code = 10 

        # --- B. CALCULATE REWARD ---
        is_new = False
        reward = 0
        
        if fault_code > 0:
            # Unique signature: Phase + Action + FaultType
            fault_sig = (phase, action_id, fault_code)
            
            if fault_sig not in self.fault_history:
                is_new = True
                self.fault_history.add(fault_sig)
                reward = 100 # Discovery Bonus
                
                if fault_code == 10:
                    reward += 500 # High Value Target
            else:
                reward = 1 # Small reward for repeating known fault

        return reward, is_new, fault_code

    def close(self):
        if self.proc:
            try:
                self.proc.stdin.write("EXIT\n")
                self.proc.stdin.flush()
                self.proc.wait(timeout=1)
            except:
                self.proc.terminate()
















#include <iostream>
#include <string>
#include <vector>
#include "base/config.h"
#include "base/factory.h"
#include "base/request.h"
#include "frontend/frontend.h"
#include "memory_system/memory_system.h"

using namespace Ramulator;

int main(int argc, char* argv[]) {
  if (argc < 2) {
    std::cerr << "Usage: " << argv[0] << " <config.yaml>" << std::endl;
    return 1;
  }

  // 1. Load Config
  YAML::Node config = Config::parse_config_file(std::string(argv[1]), {});

  // 2. Build Memory System
  auto* frontend = Factory::create_frontend(config);
  auto* memsys = Factory::create_memory_system(config);

  frontend->connect_memory_system(memsys);
  memsys->connect_frontend(frontend);

  std::cout << "READY" << std::endl; // Handshake

  // 3. Listen for Commands
  std::string cmd;
  while (std::cin >> cmd) {
    if (cmd == "EXIT") break;

    if (cmd == "TICK") {
      int cycles; std::cin >> cycles;
      for(int i=0; i<cycles; i++) {
        frontend->tick();
        memsys->tick();
      }
      std::cout << "OK" << std::endl;
    }
    else if (cmd == "REQ") {
      std::string addr_hex; int is_write;
      std::cin >> addr_hex >> is_write;
      uint64_t addr = std::stoull(addr_hex, nullptr, 16);
      
      bool accepted = frontend->receive_external_requests(
          is_write ? 0 : 1, addr, 0, [](Request& r){}
      );
      std::cout << (accepted ? "ACCEPTED" : "STALLED") << std::endl;
    }
  }

  frontend->finalize();
  memsys->finalize();
  return 0;
}













#!/bin/bash
set -e

# 1. Copy driver into Ramulator source tree
cp interactive_driver.cpp ramulator2/src/ramulator_interactive.cpp

# 2. Tell CMake to build it (only if not already added)
if ! grep -q "ramulator_interactive" ramulator2/src/CMakeLists.txt; then
    echo "Adding target to CMakeLists..."
    cat <<EOF >> ramulator2/src/CMakeLists.txt
add_executable(ramulator_interactive src/ramulator_interactive.cpp)
target_link_libraries(ramulator_interactive PRIVATE ramulator_lib yaml-cpp spdlog::spdlog)
target_include_directories(ramulator_interactive PRIVATE src)
EOF
fi

# 3. Build it
cd ramulator2/build
cmake .. -DCMAKE_POSITION_INDEPENDENT_CODE=ON
make -j$(nproc)

echo "‚úÖ Executable created at: $(pwd)/ramulator_interactive"







# Verify the file is there first
ls -l ramulator2/build/ramulator_interactive

# Run training
python3 main.py
